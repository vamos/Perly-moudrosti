/* REDBank | Vampire Blood Bank Database */

DROP TABLE Client CASCADE CONSTRAINTS;
DROP TABLE Employee CASCADE CONSTRAINTS;
DROP TABLE Donor CASCADE CONSTRAINTS;
DROP TABLE Test CASCADE CONSTRAINTS;
DROP TABLE Invitation CASCADE CONSTRAINTS;
DROP TABLE Branch CASCADE CONSTRAINTS;
DROP TABLE Fix CASCADE CONSTRAINTS;
DROP TABLE Collection CASCADE CONSTRAINTS;
DROP TRIGGER on_null_fix_id;
DROP SEQUENCE fix_seq;
DROP TRIGGER check_donor_age;
DROP TRIGGER delete_old_donors;

alter session set nls_date_format = 'DD-MON-YYYY';
SET SERVEROUTPUT ON;                                                      --DBMS_OUTPUT
--alter session set ddl_lock_timeout = 300;                               --unlock incomplete transactions

-- generalization is done via tables of subtypes with attributes of supertype
CREATE TABLE Client (
  Id     NUMBER(6,0) GENERATED BY DEFAULT ON NULL AS IDENTITY,            -- client id
  title  VARCHAR(16),
  fname  VARCHAR(16) NOT NULL,
  sname  VARCHAR(16) NOT NULL,
  street VARCHAR(16),
  town   VARCHAR(16)
);

CREATE TABLE Employee (
  Id     NUMBER(6,0) GENERATED BY DEFAULT ON NULL AS IDENTITY,            -- employee id
  pId    VARCHAR(16) NOT NULL,                                            -- personal id -- rodne cislo
  title  VARCHAR(16),
  fname  VARCHAR(16) NOT NULL,
  sname  VARCHAR(16) NOT NULL,
  gender VARCHAR(16),
  street VARCHAR(16),
  town   VARCHAR(16),
  email  VARCHAR(36)
);

CREATE TABLE Donor (
  Id        NUMBER(6,0) GENERATED BY DEFAULT ON NULL AS IDENTITY,         -- donor id
  pId       date NOT NULL,                                                -- personal id -- rodne cislo
  title     VARCHAR(16),
  fname     VARCHAR(16) NOT NULL,
  sname     VARCHAR(16) NOT NULL,
  gender    VARCHAR(16),
  street    VARCHAR(16),
  town      VARCHAR(16),
  email     VARCHAR(36),
  bgroup    VARCHAR(2),                                                   -- blood group
  last_col  DATE                                                          -- date of last blood collection
);

CREATE TABLE Test (
  tId        NUMBER(6,0) GENERATED BY DEFAULT ON NULL AS IDENTITY,
  "date" DATE,
  result CHAR(1),
  eId    NUMBER(6,0),                                                     -- employee id
  dId    NUMBER(6,0)                                                      -- donor id
);

CREATE TABLE Invitation (
  iId       NUMBER(6,0) GENERATED BY DEFAULT ON NULL AS IDENTITY,
  dId       NUMBER(6,0)     NOT NULL,                                     -- donor id
  branch    VARCHAR(20) NOT NULL,
  "date"    DATE,
  arrived  CHAR(1)                                                        -- Y / N
  constraint arrived_ck check ( arrived in ('Y','N'))
);

CREATE TABLE Branch (                                                     -- pobocka
  name   VARCHAR(20) NOT NULL,
  pool INTEGER
);

CREATE TABLE Fix (                                                        -- davka
  --fId   NUMBER(6,0) GENERATED BY DEFAULT ON NULL AS IDENTITY,
  fId   NUMBER(6,0) GENERATED BY DEFAULT AS IDENTITY,
  "rdate"    DATE,                                                        -- reservation date
  "pdate"    DATE,                                                        -- pick-up date
  cId    NUMBER(6,0),                                                     -- client id
  coId   NUMBER(6,0)     NOT NULL,                                        -- collection id
  branchId  VARCHAR(20)
);

CREATE TABLE Collection (                                                 -- odber
  coId   NUMBER(6,0) GENERATED BY DEFAULT ON NULL AS IDENTITY,
  "date"  DATE,
  Id1   NUMBER(6,0)      NOT NULL,                                        -- 1st test id
  Id2   NUMBER(6,0)      NOT NULL                                         -- 2nd test id
);


-- FOREIN KEYS DECLARATION
ALTER TABLE Client
  ADD CONSTRAINT PK_Client PRIMARY KEY (Id);
ALTER TABLE Employee
  ADD CONSTRAINT PK_Employee PRIMARY KEY (Id);
ALTER TABLE Donor
  ADD CONSTRAINT PK_Donor PRIMARY KEY (Id);
ALTER TABLE Test
  ADD CONSTRAINT PK_Test PRIMARY KEY (tId);
ALTER TABLE Invitation
  ADD CONSTRAINT PK_Invitation PRIMARY KEY (iId);
ALTER TABLE Branch
  ADD CONSTRAINT PK_Branch PRIMARY KEY (name);
ALTER TABLE Fix
  ADD CONSTRAINT PK_Fix PRIMARY KEY (fId);
ALTER TABLE Collection
  ADD CONSTRAINT PK_Collection PRIMARY KEY (coId);

-- FOREIN KEYS DECLARATION
ALTER TABLE Test
  ADD CONSTRAINT FK_Test_eId
FOREIGN KEY (eId) REFERENCES Employee (Id) ON DELETE CASCADE;
ALTER TABLE Test
  ADD CONSTRAINT FK_Test_dId
FOREIGN KEY (dId) REFERENCES Donor (Id) ON DELETE CASCADE;

ALTER TABLE Collection
  ADD CONSTRAINT FK_Collection_Id1
FOREIGN KEY (Id1) REFERENCES Test (tId) ON DELETE CASCADE;
ALTER TABLE Collection
  ADD CONSTRAINT FK_Collection_Id2
FOREIGN KEY (Id2) REFERENCES Test (tId) ON DELETE CASCADE;

ALTER TABLE Invitation
  ADD CONSTRAINT FK_Invitation_dId
FOREIGN KEY (dId) REFERENCES Donor (Id) ON DELETE CASCADE;
ALTER TABLE Invitation
  ADD CONSTRAINT FK_Invitation_Branch
FOREIGN KEY (branch) REFERENCES Branch (name) ON DELETE CASCADE;

ALTER TABLE Fix
  ADD CONSTRAINT FK_Fix_coId
FOREIGN KEY (coId) REFERENCES Collection (coId) ON DELETE CASCADE;
ALTER TABLE Fix
  ADD CONSTRAINT FK_Fix_branch
FOREIGN KEY (branchId) REFERENCES Branch (name) ON DELETE CASCADE;
ALTER TABLE Fix
  ADD CONSTRAINT FK_Fix_Client
FOREIGN KEY (cId) REFERENCES Client (Id) ON DELETE CASCADE;

-- TRIGGERS
CREATE SEQUENCE fix_seq START WITH 1;

CREATE OR REPLACE TRIGGER  on_null_fix_id
  BEFORE INSERT ON Fix
  FOR EACH ROW
BEGIN
  IF :NEW.fid IS NULL THEN
    :NEW.fId := fix_seq.nextval;
  END IF;
END;
/

-- DOUBLE TRIGGER / CHECK DONOR AGE BEFORE INSERT, IF TOO OLD DO NOT ADD
CREATE OR REPLACE TRIGGER check_donor_age
   AFTER INSERT
   ON Donor
   FOR EACH ROW
   DECLARE
   donor_age number;
BEGIN
SELECT MONTHS_BETWEEN(TRUNC(sysdate), TO_DATE(:new.pId,'DD-MON-YYYY'))/12 INTO DONOR_AGE FROM DUAL;
    IF (DONOR_AGE > 21 ) THEN
    dbms_output.put_line('DONOR IS TOO OLD, NOT ADDED!');
    OWA.cgi_var_name (OWA.cgi_var_name.COUNT + 1) := :NEW.ROWID;
   END IF;
END check_donor_age;
/
CREATE OR REPLACE TRIGGER delete_old_donors
   AFTER INSERT
   ON Donor
BEGIN
 /* We'll delete rows with a=2 again */
   FOR i IN 1 .. OWA.cgi_var_name.COUNT
   LOOP
      DELETE FROM Donor
            WHERE ROWID = OWA.cgi_var_name (i);
   END LOOP;
END delete_old_donors;
/

-- DATA
INSERT INTO Client
VALUES (NULL, 'Count', 'Alucard', 'III', 'Castlevania st.6', 'Chisinau');
INSERT INTO Client
VALUES (NULL, 'Lady', 'Elvira', 'Nasty de Mort', 'Rue Jarry 66', 'Paris');
INSERT INTO Client
VALUES (NULL, 'Count', 'von', 'Count', 'Sesame St', 'Fictional');
INSERT INTO Client
VALUES (NULL, 'Baron', 'Hugo', 'Haas', 'Cervena', 'Brno');

INSERT INTO Employee
VALUES (NULL, '7212120345', 'Dr', 'John', 'Ithurts', 'M','Sin st.42','Sin City','ilikecrickets@hotmail.com');
INSERT INTO Employee
VALUES (NULL, '6811093245', 'Dr', 'Dana', 'Scully', 'F', 'Dark st.76','Sin City', 'iwanttobelieve@protonmail.com');
INSERT INTO Employee
VALUES (NULL, '6611093245', 'Dr', 'Gregory', 'House', 'M', 'Hospital st.12','New Jersey', 'everybodydies@drama.com');

INSERT INTO Donor
VALUES (NULL,'1-MAY-2000', 'Mr', 'Mike', 'Meatshield', 'F','Folklore st.554', 'London', 'winteriscomming@hotmail.com' , '0' , TO_DATE('14.02.2019', 'dd.mm.yyyy'));
INSERT INTO Donor
VALUES (NULL, '1-MAY-2000','Ms', 'Mary', 'Bloody','F', 'Tudor st.39', 'Cardiff', 'tudors@mail.co.uk', 'AB' , TO_DATE('09.03.2018', 'dd.mm.yyyy'));
INSERT INTO Donor
VALUES (NULL, '1-MAY-2000','', 'Pawn', 'Sacrifice','M', 'Jupiter st.7', 'Cape Canaveral', 'jmc@nasawannabe.org', 'AB' , TO_DATE('09.03.2018', 'dd.mm.yyyy'));

INSERT INTO Branch
VALUES ('Coronary St', 66666669);
INSERT INTO Branch
VALUES ('Camarilla St', 43287432);

INSERT INTO Test -- date, result, employee, donor
VALUES (NULL, TO_DATE('15.01.2019', 'dd.mm.yyyy'), '1', 2, 2);
INSERT INTO Test
VALUES (NULL, TO_DATE('14.01.2019', 'dd.mm.yyyy'), '0', 1, 1);
INSERT INTO Test
VALUES (NULL, TO_DATE('14.01.2019', 'dd.mm.yyyy'), '0', 1, 1);
INSERT INTO Test
VALUES (NULL, TO_DATE('14.02.2019', 'dd.mm.yyyy'), '0', 1, 1);
INSERT INTO Test
VALUES (NULL, TO_DATE('14.02.2019', 'dd.mm.yyyy'), '0', 1, 1);
INSERT INTO Test
VALUES (NULL, TO_DATE('15.02.2019', 'dd.mm.yyyy'), '0', 2, 2);
INSERT INTO Test
VALUES (NULL, TO_DATE('15.02.2019', 'dd.mm.yyyy'), '0', 2, 2);


INSERT INTO Invitation -- client, branch, date, arrived?
VALUES (NULL, 2, 'Coronary St', TO_DATE('12.01.2019', 'dd.mm.yyyy'), 'Y');
INSERT INTO Invitation
VALUES (NULL, 1, 'Coronary St', TO_DATE('12.01.2019', 'dd.mm.yyyy'), 'Y');
INSERT INTO Invitation
VALUES (NULL, 2, 'Coronary St', TO_DATE('12.02.2019', 'dd.mm.yyyy'), 'Y');
INSERT INTO Invitation
VALUES (NULL, 3, 'Camarilla St', TO_DATE('01.12.2019', 'dd.mm.yyyy'), 'Y');

INSERT INTO Collection -- date, test1, test2
VALUES (NULL, TO_DATE('14.01.2019', 'dd.mm.yyyy'), 2, 3);
INSERT INTO Collection
VALUES (NULL, TO_DATE('14.02.2019', 'dd.mm.yyyy'), 4, 5);
INSERT INTO Collection
VALUES (NULL, TO_DATE('15.02.2019', 'dd.mm.yyyy'), 6, 7);

INSERT INTO Fix -- reservation date, pick up date, client, collection, branch
VALUES (NULL, TO_DATE('15.01.2019', 'dd.mm.yyyy'),TO_DATE('16.01.2019', 'dd.mm.yyyy'), 2 ,1 ,'Coronary St');
INSERT INTO Fix
VALUES (NULL, TO_DATE('15.01.2019', 'dd.mm.yyyy'),TO_DATE('16.01.2019', 'dd.mm.yyyy'), 2 ,2 ,'Coronary St');
INSERT INTO Fix
VALUES (NULL, TO_DATE('16.01.2019', 'dd.mm.yyyy'),TO_DATE('17.01.2019', 'dd.mm.yyyy'), 1 ,3 ,'Coronary St');


-- THIRSTIEST CLIENTS / SHOW ALL CLIENTS AND NUMBER OF FIXES ORDERED BY THEM SORTED DESCENDINGLY
SELECT Client.sname, COUNT(*) AS TOTAL_FIXs_ORDERED
FROM Client JOIN Fix ON Client.Id=Fix.cId
GROUP BY Client.sname
ORDER BY TOTAL_FIXs_ORDERED DESC;

-- MOST SUCKED DONORS / SHOW DONORS FROM WHOM WE COLLECTED MOST BLOOD / ONLY COLLECTIONS WITH BOTH TESTS PASSED / SORTED DESCENDINGLY
SELECT DISTINCT Donor.sname, COUNT(*)/2 AS NR_OF_COLLECTIONS
FROM Donor JOIN Test ON Donor.Id=Test.dId JOIN Collection
ON Test.tId IN (Collection.Id1, Collection.Id2)
GROUP BY Donor.sname
ORDER BY NR_OF_COLLECTIONS DESC;

-- WHICH EMPLOYEES WERE TESTING ON JANUARY 15, 2019?
SELECT DISTINCT pid, title, fname, sname
FROM Employee JOIN Test ON Employee.id = Test.eid
WHERE "date"= DATE '2019-01-15';


-- MOST RELIABLE DONORS / PASSED ALL TESTS /
SELECT fname, sname
FROM Donor
WHERE EXISTS (SELECT dId FROM Test WHERE Test.dId = Donor.Id GROUP BY dId HAVING sum(result) < 1);

-- DONORS WHICH ACCEPTED OUR INVITATION IN 2019
SELECT Donor.fname, Donor.sname
FROM Donor
WHERE Id IN ( SELECT dId
              FROM Invitation
              WHERE "date" BETWEEN DATE '2019-01-01' AND DATE '2019-12-31');


-- PROCEDURES

/*
 *	Between 12.01.2019 and 20.01.2019 in 
 *	Coronary Street will be Dangerous Vampires around!
 *	This procedure prints "email" to warn them
 */
CREATE OR REPLACE PROCEDURE warn_donors AS
CURSOR invs
IS
	SELECT *
	FROM Invitation;

l_inv invs%ROWTYPE;
BEGIN
	OPEN invs;
	LOOP
		FETCH invs INTO	l_inv;
		EXIT WHEN invs%NOTFOUND;
		IF l_inv.branch='Coronary St' AND l_inv."date"
	        BETWEEN '12.01.2019' AND '20.01.2019' THEN

			DECLARE
				l_donor Donor%ROWTYPE;
			BEGIN
				SELECT *
				INTO l_donor
				FROM Donor
				WHERE Donor.Id = l_inv.dId;
				DBMS_OUTPUT.put_line('To:');
				DBMS_OUTPUT.put_line(l_donor.email);
				DBMS_OUTPUT.put_line('');
				DBMS_OUTPUT.put_line('Be aware that between 12.01.2019 and 20.01.2019 in Coronary Street will be Dangerous Vampires around!' );
				DBMS_OUTPUT.put_line('TAKE CARE!!');
				DBMS_OUTPUT.put_line('');
			END;

		END IF;
	END LOOP;
	CLOSE invs;
	EXCEPTION
		WHEN OTHERS THEN
			RAISE_APPLICATION_ERROR(-666,'BLOODY ERROR');
END;



CREATE OR REPLACE PROCEDURE remove_donor (Id NUMBER) AS
BEGIN
	DELETE FROM Donor
    	WHERE Donor.Id = remove_donor.Id;
    DBMS_OUTPUT.put_line('Donor removed!');
END;
/


CREATE OR REPLACE PROCEDURE bad_blood AS
BEGIN
  DELETE
  FROM Donor
  WHERE EXISTS (SELECT dId FROM Test
                WHERE Test.dId = Donor.Id AND Test.result = 1
                GROUP BY dId
                HAVING sum(result) >= 3);
END;
/

-- EXPLAIN PLAN

DROP INDEX client_sname;

EXPLAIN PLAN FOR SELECT sname, COUNT(*) AS TOTAL_FIXs_ORDERED
FROM Client JOIN Fix ON Client.Id=Fix.cId
GROUP BY Client.sname;
-- ORDER BY TOTAL_FIXs_ORDERED DESC;
SELECT PLAN_TABLE_OUTPUT FROM TABLE(DBMS_XPLAN.DISPLAY());

CREATE INDEX client_sname
  ON Client (sname);

EXPLAIN PLAN FOR SELECT /*+ INDEX(Client client_sname)*/ sname, COUNT(*) AS TOTAL_FIXs_ORDERED
FROM Client JOIN Fix ON Client.Id=Fix.cId
GROUP BY Client.sname;
--ORDER BY TOTAL_FIXs_ORDERED DESC;
SELECT PLAN_TABLE_OUTPUT FROM TABLE(DBMS_XPLAN.DISPLAY());


-- ACCESS RIGHTS
GRANT SELECT ON Client TO xvodak05;
REVOKE ALL ON Client FROM xvodak05;
GRANT ALL ON Employee TO xvodak05;
GRANT ALL ON Donor TO xvodak05;
GRANT ALL ON Test TO xvodak05;
GRANT ALL ON Invitation TO xvodak05;
GRANT ALL ON Branch TO xvodak05;
GRANT ALL ON Fix TO xvodak05;
GRANT ALL ON Collection TO xvodak05;

GRANT EXECUTE ON bad_blood TO xvodak05;
REVOKE EXECUTE ON bad_blood FROM xvodak05;


-- MATERIALIZED VIEW
DROP MATERIALIZED VIEW addTest;

CREATE MATERIALIZED VIEW LOG ON Test WITH PRIMARY KEY,ROWID(result)INCLUDING NEW VALUES;

CREATE MATERIALIZED VIEW addTest
CACHE
BUILD IMMEDIATE
REFRESH FAST ON COMMIT
ENABLE QUERY REWRITE
AS SELECT Test.result, COUNT(Test.result)
FROM Test
GROUP BY Test.result;

GRANT SELECT ON addTest TO xvodak05;

SELECT * from addTest;
INSERT INTO Test VALUES (NULL, TO_DATE('15.02.2019', 'dd.mm.yyyy'), '0', 2, 2);
COMMIT;
SELECT * from addTest;


-- PROCEDURE CALLS

call bad_blood();

call WARN_DONORS();

call remove_donor(1);
